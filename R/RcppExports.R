# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

Xbeta_cpp <- function(X, beta) {
    .Call(`_lame_Xbeta_cpp`, X, beta)
}

outer_cpp <- function(a, b) {
    .Call(`_lame_outer_cpp`, a, b)
}

gof_stats_cpp <- function(Y) {
    .Call(`_lame_gof_stats_cpp`, Y)
}

#' Sample dynamic additive effects with AR(1) evolution
#' 
#' Updates row effects (a) and column effects (b) that evolve over time
#' according to AR(1) processes: \eqn{a_{i,t} = \rho_{ab} a_{i,t-1} + \epsilon_{i,t}}
#' 
#' @param a_current Current 2D array of row effects (n x T)
#' @param b_current Current 2D array of column effects (n x T) 
#' @param Z_array 3D array of latent positions (n x n x T)
#' @param EZ_array 3D array of expected values without additive effects (n x n x T)
#' @param rho_ab AR(1) parameter for additive effects
#' @param sigma_ab Innovation standard deviation
#' @param Sab Covariance matrix for a and b (2x2)
#' @param symmetric Whether the network is symmetric
#' @return List with updated a and b arrays
sample_dynamic_ab_cpp <- function(a_current, b_current, Z_array, EZ_array, rho_ab, sigma_ab, Sab, symmetric) {
    .Call(`_lame_sample_dynamic_ab_cpp`, a_current, b_current, Z_array, EZ_array, rho_ab, sigma_ab, Sab, symmetric)
}

#' Sample AR(1) parameter for dynamic additive effects
#' 
#' Uses Metropolis-Hastings to sample rho_ab given the time series of effects
#' 
#' @param a_mat Matrix of row effects (n x T)
#' @param b_mat Matrix of column effects (n x T)
#' @param sigma_ab Innovation standard deviation
#' @param rho_current Current value of rho
#' @param symmetric Whether the network is symmetric
#' @return Updated rho value
sample_rho_ab_cpp <- function(a_mat, b_mat, sigma_ab, rho_current, symmetric) {
    .Call(`_lame_sample_rho_ab_cpp`, a_mat, b_mat, sigma_ab, rho_current, symmetric)
}

#' Sample innovation variance for dynamic additive effects
#' 
#' @param a_mat Matrix of row effects (n x T)
#' @param b_mat Matrix of column effects (n x T)
#' @param rho_ab AR(1) parameter
#' @param symmetric Whether the network is symmetric
#' @param prior_shape Shape parameter for inverse gamma prior
#' @param prior_scale Scale parameter for inverse gamma prior
#' @return Updated sigma_ab value
sample_sigma_ab_cpp <- function(a_mat, b_mat, rho_ab, symmetric, prior_shape = 2.0, prior_scale = 1.0) {
    .Call(`_lame_sample_sigma_ab_cpp`, a_mat, b_mat, rho_ab, symmetric, prior_shape, prior_scale)
}

#' Initialize dynamic additive effects with AR(1) structure
#' 
#' @param n Number of actors
#' @param T Number of time points
#' @param rho_ab AR(1) parameter
#' @param sigma_ab Innovation standard deviation
#' @param mean_a Mean for row effects
#' @param mean_b Mean for column effects
#' @return List with initialized a and b matrices
init_dynamic_ab_cpp <- function(n, T, rho_ab, sigma_ab, mean_a = 0.0, mean_b = 0.0) {
    .Call(`_lame_init_dynamic_ab_cpp`, n, T, rho_ab, sigma_ab, mean_a, mean_b)
}

#' Update dynamic latent positions using AR(1) process
#' 
#' @param U_current Current 3D array of U positions (n x R x T)
#' @param V_current Current 3D array of V positions (n x R x T) 
#' @param ET 3D array of residuals (n x n x T)
#' @param rho_uv AR(1) autoregressive parameter for latent positions
#' @param sigma_uv Innovation standard deviation for latent positions
#' @param s2 Dyadic variance
#' @param shrink Whether to apply shrinkage
#' @param symmetric Whether network is symmetric
#' @return List with updated U and V arrays
rUV_dynamic_fc_cpp <- function(U_current, V_current, ET, rho_uv, sigma_uv, s2, shrink, symmetric) {
    .Call(`_lame_rUV_dynamic_fc_cpp`, U_current, V_current, ET, rho_uv, sigma_uv, s2, shrink, symmetric)
}

#' Initialize dynamic latent positions with AR(1) structure
#' 
#' @param n Number of actors
#' @param R Latent dimension
#' @param T Number of time points
#' @param rho_uv AR(1) parameter
#' @param sigma_uv Innovation standard deviation
#' @return 3D array of latent positions (n x R x T)
init_dynamic_positions <- function(n, R, T, rho_uv, sigma_uv) {
    .Call(`_lame_init_dynamic_positions`, n, R, T, rho_uv, sigma_uv)
}

#' Sample AR(1) parameter for dynamic latent factors
#' 
#' @param U_cube 3D array of U positions (n x R x T)
#' @param V_cube 3D array of V positions (n x R x T)
#' @param sigma_uv Innovation standard deviation
#' @param rho_current Current value of rho
#' @param symmetric Whether network is symmetric
#' @return Updated rho value
sample_rho_uv <- function(U_cube, V_cube, sigma_uv, rho_current, symmetric) {
    .Call(`_lame_sample_rho_uv`, U_cube, V_cube, sigma_uv, rho_current, symmetric)
}

#' Sample innovation variance for dynamic latent factors
#' 
#' @param U_cube 3D array of U positions (n x R x T)
#' @param V_cube 3D array of V positions (n x R x T)
#' @param rho_uv AR(1) parameter
#' @param symmetric Whether network is symmetric
#' @return Updated sigma_uv value
sample_sigma_uv <- function(U_cube, V_cube, rho_uv, symmetric) {
    .Call(`_lame_sample_sigma_uv`, U_cube, V_cube, rho_uv, symmetric)
}

count_four_cycles_bip_cpp <- function(Y) {
    .Call(`_lame_count_four_cycles_bip_cpp`, Y)
}

compute_degrees_bip_cpp <- function(Y) {
    .Call(`_lame_compute_degrees_bip_cpp`, Y)
}

clustering_coef_bip_cpp <- function(Y) {
    .Call(`_lame_clustering_coef_bip_cpp`, Y)
}

get_EZ_bip_cpp <- function(base, a, b, U, V, G) {
    .Call(`_lame_get_EZ_bip_cpp`, base, a, b, U, V, G)
}

outer_ab_bip_cpp <- function(a, b) {
    .Call(`_lame_outer_ab_bip_cpp`, a, b)
}

get_EZ_cpp <- function(Xlist, beta, ab, U, V) {
    .Call(`_lame_get_EZ_cpp`, Xlist, beta, ab, U, V)
}

rmvnorm_cpp <- function(n, mu, Sigma) {
    .Call(`_lame_rmvnorm_cpp`, n, mu, Sigma)
}

simZ_cpp <- function(EZ, rho, s2 = 1.0) {
    .Call(`_lame_simZ_cpp`, EZ, rho, s2)
}

simY_nrm_cpp <- function(EY, rho, s2) {
    .Call(`_lame_simY_nrm_cpp`, EY, rho, s2)
}

rZ_nrm_fc_cpp <- function(Z, EZ, rho, s2, Y) {
    .Call(`_lame_rZ_nrm_fc_cpp`, Z, EZ, rho, s2, Y)
}

mhalf_cpp <- function(M) {
    .Call(`_lame_mhalf_cpp`, M)
}

design_array_cpp <- function(Xrow, Xcol, Xdyad, intercept, n, symmetric) {
    .Call(`_lame_design_array_cpp`, Xrow, Xcol, Xdyad, intercept, n, symmetric)
}

precomputeX_cpp <- function(X) {
    .Call(`_lame_precomputeX_cpp`, X)
}

llsrmRho_cpp <- function(Y, Sab, rhos, s2) {
    .Call(`_lame_llsrmRho_cpp`, Y, Sab, rhos, s2)
}

rbeta_ab_fc_cpp <- function(Z, Sab, rho, X, s2, offset, iV0, m0, g) {
    .Call(`_lame_rbeta_ab_fc_cpp`, Z, Sab, rho, X, s2, offset, iV0, m0, g)
}

ldZgbme_opt_cpp <- function(Z, Y, EZ, rho, s2) {
    .Call(`_lame_ldZgbme_opt_cpp`, Z, Y, EZ, rho, s2)
}

array_to_list_cpp <- function(arr, actorByYr, pdLabs, actorIndices) {
    .Call(`_lame_array_to_list_cpp`, arr, actorByYr, pdLabs, actorIndices)
}

rrho_fc_cpp <- function(Z, Sab, s2, offset, ngp, asp) {
    .Call(`_lame_rrho_fc_cpp`, Z, Sab, s2, offset, ngp, asp)
}

ldZgbme_cpp <- function(Z, Y, EZ, rho, s2) {
    .Call(`_lame_ldZgbme_cpp`, Z, Y, EZ, rho, s2)
}

rZ_pois_fc_cpp <- function(Z, EZ, rho, s2, Y) {
    .Call(`_lame_rZ_pois_fc_cpp`, Z, EZ, rho, s2, Y)
}

ldZgbme_nrm_cpp <- function(Z, Y, EZ, rho, s2) {
    .Call(`_lame_ldZgbme_nrm_cpp`, Z, Y, EZ, rho, s2)
}

simY_pois <- function(EZ) {
    .Call(`_lame_simY_pois`, EZ)
}

rwish_opt_cpp <- function(S0, nu) {
    .Call(`_lame_rwish_opt_cpp`, S0, nu)
}

rUV_rep_opt_cpp <- function(ET, U, V, rho, s2, iSe2, maxmargin, shrink, rLoopIDs) {
    .Call(`_lame_rUV_rep_opt_cpp`, ET, U, V, rho, s2, iSe2, maxmargin, shrink, rLoopIDs)
}

rUV_sym_opt_cpp <- function(E, U, V, s2, shrink, uLoopIDs) {
    .Call(`_lame_rUV_sym_opt_cpp`, E, U, V, s2, shrink, uLoopIDs)
}

rwish_cpp <- function(S0, nu) {
    .Call(`_lame_rwish_cpp`, S0, nu)
}

rUV_rep_fc_cpp <- function(ET, U, V, rho, s2, iSe2, maxmargin, shrink, rLoopIDs) {
    .Call(`_lame_rUV_rep_fc_cpp`, ET, U, V, rho, s2, iSe2, maxmargin, shrink, rLoopIDs)
}

rUV_sym_fc_cpp <- function(E, U, V, s2, shrink, uLoopIDs) {
    .Call(`_lame_rUV_sym_fc_cpp`, E, U, V, s2, shrink, uLoopIDs)
}

rZ_bin_fc_cpp <- function(ZT, EZT, rho, YT) {
    .Call(`_lame_rZ_bin_fc_cpp`, ZT, EZT, rho, YT)
}

rbeta_ab_rep_fc_cpp <- function(ZT, Xr, Xc, mX, mXt, XX, XXt, iSe2, Sabs, k, G) {
    .Call(`_lame_rbeta_ab_rep_fc_cpp`, ZT, Xr, Xc, mX, mXt, XX, XXt, iSe2, Sabs, k, G)
}

rrho_mh_rep_cpp <- function(ET, rho, s2) {
    .Call(`_lame_rrho_mh_rep_cpp`, ET, rho, s2)
}

rs2_rep_fc_cpp <- function(ET, rhoMat) {
    .Call(`_lame_rs2_rep_fc_cpp`, ET, rhoMat)
}

sample_U_bip_cpp <- function(R, V, G, lambdaU, s2) {
    .Call(`_lame_sample_U_bip_cpp`, R, V, G, lambdaU, s2)
}

sample_V_bip_cpp <- function(R, U, G, lambdaV, s2) {
    .Call(`_lame_sample_V_bip_cpp`, R, U, G, lambdaV, s2)
}

sample_G_bip_cpp <- function(R, U, V, lambdaG, s2) {
    .Call(`_lame_sample_G_bip_cpp`, R, U, V, lambdaG, s2)
}

canon_orient_bip_cpp <- function(U, V, G) {
    .Call(`_lame_canon_orient_bip_cpp`, U, V, G)
}

